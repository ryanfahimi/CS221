Ryan Fahimi
20676243
1.
#include <stdio.h>

int main()
{
    int x = 2, y = 12;
    int *p = &x, *q = &y;

    printf("Address of x: %p, Value of x: %d\n", &x, x);
    printf("Value of p: %p, Value of *p: %d\n", p, *p);
    printf("Address of y: %p, Value of y: %d\n", &y, y);
    printf("Value of q: %p, Value of *q: %d\n", q, *q);
    printf("Address of p: %p\n", &p);
    printf("Address of q: %p\n", &q);

    return 0;
}

2. 
The output of the first loop:
0 00000000005ffe80 11
1 00000000005ffe84 40
2 00000000005ffe88 27
3 00000000005ffe8c 0
4 00000000005ffe90 3

The output of the second loop:
0 00000000005ffe80 11
1 00000000005ffe84 40
2 00000000005ffe88 27
3 00000000005ffe8c 0
4 00000000005ffe90 3

3.
(a) 
#include <stdio.h>

int main(void)
{
    int MyArray[3] = {10, 20, 30};
    int *p = MyArray;
    *p = 70; // set MyArray[0] to 70
    p++;
    *p = 60; // set MyArray[1] to 60
    p++;
    *p = 50; // set MyArray[2] to 50

    do
    {
        printf("%d\n", *p); // print values
        p--;
    } while (p >= MyArray);

    return 0;
}
(b)
The problem with the `findmin` function is that it is trying to change the address to which `pToMin` points, but it only changes the local copy of the pointer inside the function and not the one in the `main` function.
When you pass a pointer to a function, the function gets a copy of the pointer.
So if you change where the pointer points inside the function, the original pointer in the calling function is not affected.
In this case, `pToMin` is a pointer to a pointer, so we should dereference it to change the value of the original pointer `p` in the main function.
Here's how to fix the 'findmin' function:

void findmin(int MyArray[], int n, int **pToMin) {
    if (n <= 0) return; // no items, no minimum!
    *pToMin = MyArray;
    for (int i = 1; i < n; i++) {
        if (MyArray[i] < **pToMin) {
            *pToMin = MyArray + i;
        }
    }
}

This way, when you dereference `pToMin` inside `findmin`, you are modifying the address stored in `p` in the `main` function.
(c)
The issue in the main function is that the pointer `ptr` is uninitialized.
It doesn't point to a valid memory location when it's passed to `computeCube`, which means that when `computeCube` dereferences the pointer to store the computed cube, it's writing to an unknown location in memory. 
This can lead to undefined behavior.
To fix this, we need to ensure that `ptr` points to a valid memory location, using a local variable.
Here's how to fix the `main` function:

int main(void) {
    int result;
    int *ptr = &result;
    computeCube(5, ptr);
    printf("Five cubed is %d\n", *ptr);
}
(d)
The strequal function is designed to check if two C strings are identical.
However, there are several issues in its current implementation.

Firstly, the condition in the while loop, while (str1 != 0 && str2 != 0), checks if the pointers str1 and str2 are NULL (or 0).
This is problematic because C strings end with a null character ('\0'), not with a NULL pointer.
Therefore, the loop should check for the end of each string using the null terminator.

Secondly, the line if (str1 != str2) is checking if the pointers str1 and str2 themselves are equal, rather than comparing the characters they point to.
This will not give the desired result.
Instead, we need to dereference these pointers to compare the actual characters.

Lastly, the code uses the bool datatype but doesn't include the necessary header, <stdbool.h>.

Here's how to fix the code:
#include <stdbool.h>
#include <stdio.h>

// return true if two C strings are equal
bool strequal(const char str1[], const char str2[])
{
    int i = 0;
    while (*str1 != '\0' && *str2 != '\0')
    {
        if (*str1 != *str2) // compare corresponding characters
            return false;
        str1++; // advance to the next character
        str2++;
    }
    return *str1 == *str2; // both ended at same time ?
}

int main(void)
{
    char a[15] = "Chen, B.";
    char b[15] = "Chen, Y.J.";
    if (strequal(a, b))
        printf("They're the same person!\n");
}
(e)
The primary issue with the program is that getPtrToArray function returns a pointer to a local array anArray.
Once the function returns, the local array goes out of scope, and therefore its memory can be reclaimed or overwritten.
Thus, the returned pointer will point to memory that is no longer valid.

In addition, there's another minor issue: the variable n in the main function is uninitialized, but it's being used to determine the number of times the loop should iterate.
Even though there's an attempt to set m to 5 in getPtrToArray, this assignment has no effect on the value of n in the main function.
This could lead to unpredictable behavior, as the loop could run any number of times based on the uninitialized value of n.

4.
(a) double *student;
(b) double grades[5];
(c) student = &grades[4];
(d) *student = 17;
(e) *(grades + 3) = 72;
(f) student -= 3;
(g) student[2] = 93;
(h) student[0] = 85;

5.
(a)
double mean(const double *scores, int numScores)
{
    double total = 0;
    for (int i = 0; i < numScores; i++)
    {
        total += *(scores + i);
    }
    return total / numScores;
}
(b)
const char *findTheChar(const char *str, char chr)
{
    for (int k = 0; *(str + k) != '\0'; k++)
    {
        if (*(str + k) == chr)
        {
            return (str + k);
        }
    }
    return NULL;
}
(c)
const char *findTheChar(const char *str, char chr)
{
    while (*str != '\0')
    {
        if (*str == chr)
            return str;
        str++;
    }
    return NULL;
}

6.
(a) Functions
1. maxwell function:
Takes two integer pointers as arguments and returns a pointer pointing to the larger integer.
2. swap1 function:
Attempts to swap the addresses stored in two pointer variables.
However, since pointers in C are passed by value to functions, the swapping occurs only locally within the function and has no effect on the original pointers passed from the caller.
3. swap2 function:
Takes two integer pointers and swaps the integer values they point to.

(b) Line-by-Line Explanation of 'main'
1. Initialize `array` with values: `{5, 3, 4, 17, 22, 19}`.
2. Using the `maxwell` function, compare `array[0]` (5) with `array[2]` (4).
Since 5 is greater, `ptr` now points to `array[0]`.
3. Set the value pointed by `ptr` to `-1`. So, `array[0]` becomes -1.
The array is now `{-1, 3, 4, 17, 22, 19}`.
4. Increment `ptr` by 2. `ptr` now points to `array[2]`.
5. Modify `array[3]` (which is next to where `ptr` points) to 9. 
The array becomes `{-1, 3, 4, 9, 22, 19}`.
6. Directly set `array[1]` to 79 using pointer arithmetic.
Array now is `{-1, 79, 4, 9, 22, 19}`.
7. Print the difference between addresses of `array[5]` and `ptr`:
The output is `3` because `ptr` points to `array[2]`, and `array[5]` is three positions away.
8. `swap1` function is called but doesn't have an effect on the array as it swaps local copies of the pointers.
9. `swap2` swaps the values of `array[0]` and `array[2]`.
Array becomes `{4, 79, -1, 9, 22, 19}`.
10. Finally, the for loop prints each value in the array:'{4, 79, -1, 9, 22, 19}'.

(c) Output
3
4
79
-1
9
22
19


